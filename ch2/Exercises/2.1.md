### Exercise 2.1-1
***
Using Figure 2.2 as a model, illustrate the operation of *INSERTION-SORT* on the array A = (31, 41, 59, 26, 41, 58).

### `Answer`
The operation of *INSERTION-SORT* algorithm on the array A = (31, 41, 59, 26, 41, 58) is depicted in the following figure.

<p align="center">
    <img src="../Images/CLRS_2-1-1.png" alt="Insertion sort operation on array A">
</p>

### Exercise 2.1-2
***
Rewrite the *INSERTION-SORT* procedure to sort into nonincreasing instead of nondecreasing order.

### `Answer`
The *INSERTION-SORT* pseudocode procure to sort in nondecreasing order is presented below. Also, there is a implemented version of this procedure in C++, which
can be seen <a href="https://github.com/nicowxd/CLRS/blob/master/Algorithms/insertionSortNonDecreasing.cpp">here</a>.

```
INSERTION-SORT(A)
1   for j = 2 to A.length
2       key = A[j]
3       // Insert A[j] into the sorted sequence A[1..j-1].
4       i = j - 1
5       while i > 4 and A[i] < key // The less than comparator, now ensures that the sorted sequence is nondecreasing
6           A[i + 1] = A[i]
7           i = i - 1
8       A[i + 1] = key 
```
### Exercise 2.1-3
***
Consider the **_searching problem:_**

**Input:** A sequence of *n* numbers *A* = (a_1, a_2,..., a_n) and a value *v*.

**Output:** An index *i* such that *v* = *A*[*i*] or the special value *NIL* if *v* does not appear in *A*.

Write pseudocode for **_linear search_**, which scans through the sequence, looking for *v*. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

### `Answer`

The *LINEAR-SEARCH* pseudocode is shown below.

```
LINEAR-SEARCH(A, v)
1   i = NIL
2   for j = 1 to A.length
3       if A[j] == v
4           i = j
5           return i
6   return i
```
The loop invariant is:

    At the current index that we are evaluating, there is no index before (A[1..j-1], and A[0] = NIL) that is equal to v.

To prove this loop invariant we must show:

**Initialization:** Before the iteration of the first loop there is no number to be evaluated, therefore we must return *NIL*.

**Maintenance:** The for loop tests every index, increasing by one until the last element is evaluated. The return ensures that, if the condition (A[j] == v) holds, the *LINEAR-SEARCH* procedure is terminated and the current index is returned. Therefore, if we are testing the current index it means that the *LINEAR-SEARCH* didn't terminate and the condition didn't hold for any index before.

**Termination:** When the loop ends, by the same reason described in the **Maintenance** property, it means that we scanned the entire array A[1..n] (since j is equal to n + 1, the loop invariant holds) and there is no index j, such that A[j] == v.
This way, we should return *NIL* as stated by the problem.
